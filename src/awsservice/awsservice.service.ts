import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { User } from 'src/auth/entities/user.entity';
import {
  APIGatewayClient,
  CreateApiKeyCommand,
  CreateApiKeyCommandInput,
} from '@aws-sdk/client-api-gateway'; // Import v3 commands and clients
import { exec } from 'child_process';

@Injectable()
export class AWSService {
  private readonly logger = new Logger(AWSService.name);

  constructor(private configService: ConfigService) {}

  // Method to generate AWS API Gateway Key and associate it with user
  async createAwsApiGatewayKey(user: User): Promise<string> {
    const apiGateway = new APIGatewayClient({
      credentials: {
        accessKeyId: this.configService.get<string>('AWS_ACCESS_KEY'),
        secretAccessKey: this.configService.get<string>('AWS_SECRET_KEY'),
      },
      region: this.configService.get<string>('AWS_REGION') || 'us-east-1',
    });

    const params: CreateApiKeyCommandInput = {
      name: `api-key-${user.id}`, // Unique key name for the user
      enabled: true,
      generateDistinctId: true, // Generates a distinct API key
      value: undefined, // Let API Gateway generate the key value
    };

    try {
      const createApiKeyCommand = new CreateApiKeyCommand(params);
      const apiKeyResponse = await apiGateway.send(createApiKeyCommand); // Use the send method with v3
      this.logger.log(`Created AWS API Gateway Key for user: ${user.email}`);
      return apiKeyResponse.id; // Return the key ID generated by API Gateway
    } catch (error) {
      this.logger.error(
        `Failed to create API Gateway Key for user: ${user.email}`,
        error.message,
      );
      throw new Error('Failed to create API Gateway key');
    }
  }

  // Provision AWS VPS using Terraform
  async provisionAwsVps(user: User): Promise<string | null> {
    const region = user.instanceLocation || 'us-east-1';
    const awsAccessKey = this.configService.get<string>('AWS_ACCESS_KEY');
    const awsSecretKey = this.configService.get<string>('AWS_SECRET_KEY');
    const githubPat = this.configService.get<string>('GITHUB_PAT');

    if (!awsAccessKey || !awsSecretKey) {
      this.logger.error('AWS credentials are missing');
      throw new Error('AWS credentials are undefined');
    }

    return new Promise((resolve, reject) => {
      this.logger.log(
        `Provisioning AWS VPS for user ID ${user.id}, region: ${region}...`,
      );

      exec(
        `cd terraform && terraform init && terraform apply \
        -var="aws_region=${region}" \
        -var="aws_access_key=${awsAccessKey}" \
        -var="aws_secret_key=${awsSecretKey}" \
        -var="github_pat=${githubPat}" \
        -var="user_id=${user.id}" -auto-approve`,
        (error, stdout, stderr) => {
          if (error) {
            this.logger.error(`Error provisioning AWS VPS: ${error.message}`);
            reject(null);
            return;
          }
          if (stderr) {
            this.logger.error(`Terraform error: ${stderr}`);
            reject(null);
            return;
          }

          const match = stdout.match(/instance_public_ip = "(.*)"/);
          const vpsIp = match ? match[1] : null;
          resolve(vpsIp);
        },
      );
    });
  }

  // Teardown AWS VPS using Terraform
  async teardownAwsVps(user: User): Promise<void> {
    const region = user.instanceLocation || 'us-east-1';
    const awsAccessKey = this.configService.get<string>('AWS_ACCESS_KEY');
    const awsSecretKey = this.configService.get<string>('AWS_SECRET_KEY');
    const githubPat = this.configService.get<string>('GITHUB_PAT');

    return new Promise((resolve, reject) => {
      this.logger.log(`Destroying AWS VPS for user ID ${user.id}...`);

      exec(
        `cd terraform && ./destroy_user_resources.sh ${region} ${awsAccessKey} ${awsSecretKey} ${githubPat} ${user.id}`,
        (error, stdout, stderr) => {
          if (error) {
            this.logger.error(`Error destroying AWS VPS: ${error.message}`);
            reject(error);
            return;
          }
          if (stderr) {
            this.logger.error(`Terraform error: ${stderr}`);
            reject(new Error(stderr));
            return;
          }
          resolve();
        },
      );
    });
  }
}
