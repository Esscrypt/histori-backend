import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { User } from 'src/auth/entities/user.entity';
import {
  APIGatewayClient,
  CreateApiKeyCommand,
  CreateApiKeyCommandInput,
  CreateUsagePlanKeyCommand,
  CreateUsagePlanKeyCommandInput,
  DeleteApiKeyCommand,
  DeleteUsagePlanKeyCommand,
  GetUsageCommand,
  GetUsageCommandInput,
  GetUsagePlanCommand,
  GetUsagePlanCommandInput,
  GetUsagePlanKeysCommand,
} from '@aws-sdk/client-api-gateway'; // Import v3 commands and clients
import { exec } from 'child_process';

@Injectable()
export class AWSService {
  private readonly logger = new Logger(AWSService.name);

  private readonly usagePlanMapping: Record<string, string> = {
    Free: 'u3xg47',      // Free tier usage plan ID
    Starter: '2kks9j',   // Starter tier usage plan ID
    Growth: '2pkmuh',    // Growth tier usage plan ID
    Business: 'ujz9a5',  // Business tier usage plan ID
  };

  apiGateway: APIGatewayClient;
  
  constructor(private configService: ConfigService) {
    this.apiGateway = new APIGatewayClient({
      credentials: {
        accessKeyId: this.configService.get<string>('AWS_ACCESS_KEY'),
        secretAccessKey: this.configService.get<string>('AWS_SECRET_KEY'),
      },
      region: this.configService.get<string>('AWS_REGION') || 'us-east-1',
    });
  }

 // Method to generate AWS API Gateway Key
 async createAwsApiGatewayKey(user: User): Promise<string> {
  const apiKeyParams: CreateApiKeyCommandInput = {
    name: `api-key-${user.id}`, // Unique key name for the user
    enabled: true,
    generateDistinctId: true,   // Generates a distinct API key
    value: undefined,           // Let API Gateway generate the key value
  };

  try {
    // Create the API key
    const createApiKeyCommand = new CreateApiKeyCommand(apiKeyParams);
    const apiKeyResponse = await this.apiGateway.send(createApiKeyCommand);
    this.logger.log(`Created AWS API Gateway Key for user: ${user.id}`);
    return apiKeyResponse.id; // Return the key ID generated by API Gateway
  } catch (error) {
    this.logger.error(
      `Failed to create API Gateway Key for user: ${user.id}`,
      error.message,
    );
    throw new Error('Failed to create API Gateway key');
  }
}

  // Helper to get request count for a specific API key
  async getRequestCountForApiKey(user: User, startDate: string, endDate: string): Promise<number> {

    const usagePlanId = this.getUsagePlanIdForTier(user.tier);
    if (!usagePlanId) {
      this.logger.error(`No usage plan found for user tier: ${user.tier}`);
      throw new Error('No usage plan found for user tier');
    }

    // Get usage for the specific API key over a specific time range
    const params: GetUsageCommandInput = {
      usagePlanId, // Usage plan ID for the associated API key
      keyId: user.apiKey, // API key ID to get the request count for
      startDate, // Start date in YYYY-MM-DD format
      endDate,   // End date in YYYY-MM-DD format
    };

    try {
      const getUsageCommand = new GetUsageCommand(params);
      const usageData = await this.apiGateway.send(getUsageCommand);

      // Summing all the request counts from the usage data for each day
      // Summing all the request counts from the usage data
      const requestCount = Object.values(usageData.items || {})
        .flat(2) // Flatten two levels to get the actual numbers
        .reduce((sum, value) => sum + (typeof value === 'number' ? value : 0), 0); // Sum up only the numbers

      return requestCount;
    } catch (error) {
      this.logger.error(`Failed to get request count for API Key: ${user.apiKey}`, error.message);
      throw new Error('Failed to get request count for API key');
    }
  }

    // Helper to get the total request count for a usage plan
    async getTotalRequestCountForUsagePlan(user: User): Promise<number> {
  
      const usagePlanId = this.getUsagePlanIdForTier(user.tier);
      if (!usagePlanId) {
        this.logger.error(`No usage plan found for user tier: ${user.tier}`);
        throw new Error('No usage plan found for user tier');
      }
  
      const params: GetUsagePlanCommandInput = {
        usagePlanId, // Usage plan ID to get the total request count for
      };
  
      try {
        const command = new GetUsagePlanCommand(params);
        const usagePlanResponse = await this.apiGateway.send(command);
        // Extract the quota details from the usage plan
        const quota = usagePlanResponse.quota;
        if (!quota) {
          this.logger.warn(`No quota found for usage plan: ${usagePlanId}`);
          return Infinity; // Return "infinite" if no quota is defined
        }

        // The total allowed request count is the limit defined in the quota
        const totalRequestCount = quota.limit || 0;
      return totalRequestCount;
      } catch (error) {
        this.logger.error(`Failed to get total request count for usage plan: ${usagePlanId}`, error.message);
        throw new Error('Failed to get total request count for usage plan');
      }
    }

// Method to associate an API Gateway Key with a usage plan based on the user's tier
 // Method to associate an API Gateway Key with a usage plan based on the user's tier
 async associateKeyWithUsagePlan(apiKeyId: string, previousTier: string, currentTier: string): Promise<void> {

  if(previousTier !== currentTier) {
    const previousUsagePlanId = this.getUsagePlanIdForTier(previousTier);
    if (!previousUsagePlanId) {
      this.logger.error(`No usage plan found for user tier: ${previousTier}`);
      throw new Error('No usage plan found for user tier');
    }
    await this.removeUsagePlanForApiKey(apiKeyId, previousUsagePlanId);
  }

  const currentUsagePlanId = this.getUsagePlanIdForTier(currentTier);
    if (!currentUsagePlanId) {
      this.logger.error(`No usage plan found for user tier: ${currentUsagePlanId}`);
      throw new Error('No usage plan found for user tier');
    }

  // Step 2: Create new usage plan association
  const usagePlanKeyParams: CreateUsagePlanKeyCommandInput = {
    usagePlanId: currentUsagePlanId,  // ID of the Usage Plan to associate the key with
    keyId: apiKeyId, // ID of the API key created
    keyType: 'API_KEY', // The key type, must be 'API_KEY'
  };

  try {
    const createUsagePlanKeyCommand = new CreateUsagePlanKeyCommand(usagePlanKeyParams);
    const response = await this.apiGateway.send(createUsagePlanKeyCommand);
    
    this.logger.log(`Associated API Key with Usage Plan (${currentTier}) for api Key: ${apiKeyId}`);
    this.logger.debug(`Response from AWS: ${JSON.stringify(response)}`);
  } catch (error) {
    this.logger.error(
      `Failed to associate API Gateway Key with Usage Plan for api key: ${apiKeyId}. Error: ${error.message}`,
      error.stack,
    );
    throw new Error('Failed to associate API Gateway key with usage plan');
  }
}

async removeUsagePlanForApiKey(apiKeyId: string, usagePlanId: string): Promise<void> {
  const params = {
    usagePlanId, // The existing usage plan ID
    keyId: apiKeyId, // The API key ID
  };

  try {
    const deleteUsagePlanKeyCommand = new DeleteUsagePlanKeyCommand(params);
    await this.apiGateway.send(deleteUsagePlanKeyCommand);
    this.logger.log(`Successfully disassociated API Key ${apiKeyId} from Usage Plan ${usagePlanId}`);
  } catch (error) {
    this.logger.error(`Failed to remove API Key ${apiKeyId} from Usage Plan ${usagePlanId}`, error.message);
    throw new Error('Failed to remove API Key from existing usage plan');
  }
}

  /**
   * Remove an API key from AWS API Gateway
   * @param apiKeyId The ID of the API key to be removed
   */
  async removeApiKey(apiKeyId: string): Promise<void> {
    if (!apiKeyId) {
      this.logger.error('API Key ID is required to remove an API key.');
      throw new Error('API Key ID is required to remove an API key.');
    }

    try {
      const deleteApiKeyCommand = new DeleteApiKeyCommand({ apiKey: apiKeyId });
      await this.apiGateway.send(deleteApiKeyCommand);
      this.logger.log(`Successfully deleted API key: ${apiKeyId}`);
    } catch (error) {
      this.logger.error(`Failed to delete API key: ${apiKeyId}`, error.message);
      throw new Error(`Failed to delete API key: ${apiKeyId}`);
    }
  }

// Helper method to get the usage plan ID based on the user's tier
private getUsagePlanIdForTier(tier: string): string | undefined {
  return this.usagePlanMapping[tier];
}
  // Provision AWS VPS using Terraform
  async provisionAwsVps(user: User): Promise<string | null> {
    const region = user.instanceLocation || 'us-east-1';
    const awsAccessKey = this.configService.get<string>('AWS_ACCESS_KEY');
    const awsSecretKey = this.configService.get<string>('AWS_SECRET_KEY');
    const githubPat = this.configService.get<string>('GITHUB_PAT');

    if (!awsAccessKey || !awsSecretKey) {
      this.logger.error('AWS credentials are missing');
      throw new Error('AWS credentials are undefined');
    }

    return new Promise((resolve, reject) => {
      this.logger.log(
        `Provisioning AWS VPS for user ID ${user.id}, region: ${region}...`,
      );

      exec(
        `cd terraform && terraform init && terraform apply \
        -var="aws_region=${region}" \
        -var="aws_access_key=${awsAccessKey}" \
        -var="aws_secret_key=${awsSecretKey}" \
        -var="github_pat=${githubPat}" \
        -var="user_id=${user.id}" -auto-approve`,
        (error, stdout, stderr) => {
          if (error) {
            this.logger.error(`Error provisioning AWS VPS: ${error.message}`);
            reject(null);
            return;
          }
          if (stderr) {
            this.logger.error(`Terraform error: ${stderr}`);
            reject(null);
            return;
          }

          const match = stdout.match(/instance_public_ip = "(.*)"/);
          const vpsIp = match ? match[1] : null;
          resolve(vpsIp);
        },
      );
    });
  }

  // Teardown AWS VPS using Terraform
  async teardownAwsVps(user: User): Promise<void> {
    const region = user.instanceLocation || 'us-east-1';
    const awsAccessKey = this.configService.get<string>('AWS_ACCESS_KEY');
    const awsSecretKey = this.configService.get<string>('AWS_SECRET_KEY');
    const githubPat = this.configService.get<string>('GITHUB_PAT');

    return new Promise((resolve, reject) => {
      this.logger.log(`Destroying AWS VPS for user ID ${user.id}...`);

      exec(
        `cd terraform && ./destroy_user_resources.sh ${region} ${awsAccessKey} ${awsSecretKey} ${githubPat} ${user.id}`,
        (error, stdout, stderr) => {
          if (error) {
            this.logger.error(`Error destroying AWS VPS: ${error.message}`);
            reject(error);
            return;
          }
          if (stderr) {
            this.logger.error(`Terraform error: ${stderr}`);
            reject(new Error(stderr));
            return;
          }
          resolve();
        },
      );
    });
  }
}
